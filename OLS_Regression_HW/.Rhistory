# Compute standardized residuals from the OLS regression which makes residuals comparable across observations
standardised_res<-rstandard(ols_reg)
# For each observation, calculate the mean standardized residual of its neighbors to identify whether high or low residuals cluster spatially
resnb<-sapply(queen_neighbors, function(x) mean(standardised_res[x]))
regress_data$standardised_res <- standardised_res    #creating a new variable in the shapefile shp.
OLS.Residuals.Map <- tm_shape(regress_data)+
tm_fill(col='standardised_res',
style='quantile',
title='Standardized OLS Residuals',
palette ='Blues')+
tm_borders(col = "gray", lwd = 0.5) +  # Add this line
tm_layout(frame=FALSE, title='Standardized OLS Residuals')
OLS.Residuals.Map
#tmap_save(OLS.Residuals.Map, filename = "HW2_Plots/OLS_Residuals_Map.png", width = 8, height = 8, dpi = 300)
#Regressing residuals on their nearest neighbors.
regress_res_lm <- lm(formula=standardised_res ~ resnb)
summary(regress_res_lm)
# Perform a Monte Carlo test for Moran’s I on the standardized OLS residuals
# Arguments:
#  - standardised_res: residuals from the OLS model, standardized for comparability
#  - queenlist: the spatial weights list (queen contiguity)
#  - 999: number of random permutations (higher = more precise p-value)
#  - alternative="two.sided": tests both positive and negative spatial autocorrelation
moran.mc(standardised_res, queenlist, 999, alternative="two.sided")
# The plot shows the relationship between each observation’s residual and the average residuals of its neighboring observations
# Arguments:
#  - standardised_res: residuals from the OLS model, standardized for comparability
#  - queenlist: the spatial weights list (queen contiguity)
moran.plot(standardised_res, queenlist)
# Dependent variable: LNMEDINC (log of median income)
# Independent variables: LNMEDHVAL (log of median home value), PCTVACANT (percent vacant housing)
# Spatial weights: queenlist (based on queen contiguity)
lag_reg<-lagsarlm(formula=LNMEDHVAL ~ LNNBELPOV100 + PCTBACHMOR + PCTSINGLES + PCTVACANT, data=regress_data, queenlist)
# Dependent variable: LNMEDINC (log of median income)
# Independent variables: LNMEDHVAL (log of median home value), PCTVACANT (percent vacant housing)
# Spatial weights: queenlist (based on queen contiguity)
lag_reg<-lagsarlm(formula=LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT, data=regress_data, queenlist)
summary(lag_reg)
LR.Sarlm(lag_reg, ols_reg) #Here lag_reg is the SL output; ols_reg is the OLS output
#Prints the results of the Breusch-Pagan Test to assess whether heteroscedasticity is present (package: lmtest)
bptest.Sarlm(lag_reg, studentize=FALSE)
#Prints the results of the Koenker-Bassett Test (also known as the Studentized Breusch-Pagan Test) to assess whether heteroscedasticity is present (package: lmtest)
bptest.Sarlm(lag_reg)
#Prints the results of the Jarque-Bera Test to assess whether residuals are normal (package: tseries)
jarque.bera.test(lag_reg$residuals)
lag_res <- lag_reg$residuals
# This checks whether any spatial autocorrelation remains after accounting for the spatial lag
# Arguments:
#  - res_lag: residuals from the spatial lag model
#  - queenlist: spatial weights list (queen contiguity)
#  - 999: number of random permutations for the Monte Carlo simulation
#  - alternative="two.sided": tests both positive and negative spatial autocorrelation
lag_moran_mc <- moran.mc(lag_res, queenlist,999, alternative="two.sided")
lag_moran_mc
# Lag residual plot
moran.plot(lag_res, queenlist)
error_reg <- errorsarlm(formula=LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT, data=regress_data, queenlist)
# Extract residuals from the fitted spatial error model
error_res <- residuals(error_reg)
# Compute the mean residual value for each observation's neighbors
error_res_mean <- sapply(queen_neighbors, function(x) mean(error_res[x]))
summary(error_reg)
# Perform a likelihood ratio (LR) test comparing the spatial error model to OLS
#  - error_reg: fitted spatial error model (errorsarlm)
#  - ols_reg: fitted OLS model
LR.Sarlm(error_reg, ols_reg)
#Prints the results of the Breusch-Pagan Test to assess whether heteroscedasticity is present (package: lmtest)
bptest.Sarlm(error_reg, studentize=FALSE)
#Prints the results of the Koenker-Bassett Test (also known as the Studentized Breusch-Pagan Test) to assess whether heteroscedasticity is present (package: lmtest)
bptest.Sarlm(error_reg)
#Prints the results of the Jarque-Bera Test to assess whether residuals are normal (package: tseries)
jarque.bera.test(error_reg$residuals)
# Perform a Monte Carlo test for Moran's I on the residuals of the spatial error model
#  - error_res: residuals from the spatial error model (errorsarlm)
#  - queenlist: spatial weights list (queen contiguity)
#  - 999: number of random permutations for the Monte Carlo simulation
#  - alternative="two.sided": tests for both positive and negative spatial autocorrelation
error_moran_mc<-moran.mc(error_res, queenlist, 999, alternative="two.sided")
error_moran_mc
# Error residual plot
moran.plot(error_res, queenlist)
```{r}
# convert regress_data from df to spatial data
regress_spatial <- as(regress_data, 'Spatial')  #These analyses are easier to do when the data are of the SpatialPolygonsDataFrame class
class (regress_spatial)
# Select an adaptive bandwidth for Geographically Weighted Regression (GWR)
#   - formula: dependent variable (LNMEDINC) and predictors (LNMEDHVAL, PCTVACANT)
#   - data: regress_spatial must be a SpatialPolygonsDataFrame (converted from sf)
#   - method = "aic": uses Akaike Information Criterion to select the optimal bandwidth
#   - adapt = TRUE: uses an adaptive bandwidth (proportion of nearest neighbors)
#     instead of a fixed distance bandwidth
bandwidth <- gwr.sel(formula = LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT,
data = regress_spatial,
method = "aic",
adapt = TRUE)
bandwidth
#setting a fixed bandwidth
bandwidth_fixed<-gwr.sel(formula=LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT,
data=regress_spatial,
method = "aic",
adapt = FALSE)
bandwidth_fixed
# Formula: dependent variable (LNMEDINC) and predictors (LNMEDHVAL, PCTVACANT)
#   - data: regress_data (SpatialPolygonsDataFrame)
#   - adapt = bandwidth: uses the adaptive bandwidth selected earlier (proportion of nearest neighbors)
#   - gweight = gwr.Gauss: applies a Gaussian weighting kernel to give nearer observations more influence
#   - se.fit = TRUE: returns local standard errors for each coefficient estimate
#   - hatmatrix = TRUE: stores diagnostic info for model evaluation (e.g., local R²)
gwr_model<-gwr(formula=LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT,
data=regress_spatial,
adapt = bandwidth, #adaptive bandwidth determined by proportion of observations accounted for
gweight=gwr.Gauss,
se.fit=TRUE, #to return local standard errors
hatmatrix = TRUE)
gwr_model
# results using fixed bandwidth
gwr_model_fixed<-gwr(formula=LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT,
data=regress_spatial,
bandwidth = bandwidth_fixed, #fixed bandwidth
gweight=gwr.Gauss,
se.fit=TRUE, #to return local standard errors
hatmatrix = TRUE)
gwr_model_fixed
# Summarize the SpatialDataFrame output from the GWR model
summary(gwr_model$SDF)
gwr_results <- as.data.frame(gwr_model$SDF)
# LNNBELPOV
regress_data$coefLNNBELPOVst <- gwr_results$LNNBELPOV/gwr_results$LNNBELPOV_se
# PCTBACHMOR
regress_data$coefPCTBACHMORst <- gwr_results$PCTBACHMOR/gwr_results$PCTBACHMOR_se
# PCTSINGLES
regress_data$coefPCTSINGLESst <- gwr_results$PCTSINGLES/gwr_results$PCTSINGLES_se
# PCTVACANT
regress_data$coefPCTVACANTst <- gwr_results$PCTVACANT/gwr_results$PCTVACANT_se
regress_data$gwrE <- gwr_results$gwr.e
regress_data$localR2 <- gwr_results$localR2
#The maps above are the ones using the exact code that our professor had but it looked funky so here is the code that I made to try and fix it.
library(tmap)
# LNNBELPOV
coefLNNBELPOV <- tm_shape(regress_data) +
tm_fill(
col = "coefLNNBELPOVst",
breaks = c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf),
title = "Standardized Coef: LNNBELPOV",
palette = "-RdBu"
) +
tm_borders(col = "gray", lwd = 0.5) +
tm_layout(
frame = FALSE,
#title = "Percent of Number in Poverty (Log)",
title.position = c("center", "top"),
title.size = 1.2,
legend.position = c("RIGHT", "BOTTOM"),
legend.just = c("right", "bottom"),
legend.bg.color = "white",
legend.bg.alpha = 0.9,
legend.text.size = 0.6,
legend.title.size = 0.6,
inner.margins = c(0.1, 0.15, 0.1, 0.15)
)
coefLNNBELPOV
#tmap_save(coefLNNBELPOV, filename = "HW2_Plots/coefLNNBELPOV_Map.png", width = 8, height = 8, dpi = 300)
# PCTBACHMOR
coefPCTBACHMOR <- tm_shape(regress_data) +
tm_fill(
col = "coefPCTBACHMORst",
breaks = c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf),
title = "Standardized Coef: PCTBACHMOR",
palette = "-RdBu"
) +
tm_borders(col = "gray", lwd = 0.5) +
tm_layout(
frame = FALSE,
#title = "Percent of Bachelor's or More",
title.position = c("center", "top"),
title.size = 1.2,
legend.position = c("RIGHT", "BOTTOM"),
legend.just = c("right", "bottom"),
legend.bg.color = "white",
legend.bg.alpha = 0.9,
legend.text.size = 0.6,
legend.title.size = 0.6,
inner.margins = c(0.1, 0.15, 0.1, 0.15)
)
coefPCTBACHMOR
#tmap_save(coefPCTBACHMOR, filename = "HW2_Plots/coefPCTBACHMOR_Map.png", width = 8, height = 8, dpi = 300)
coefPCTSINGLES <- tm_shape(regress_data) +
tm_fill(
col = "coefPCTSINGLESst",
breaks = c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf),
title = "Standardized Coef: PCTSINGLES",
palette = "-RdBu"
) +
tm_borders(col = "gray", lwd = 0.5) +
tm_layout(
frame = FALSE,
#title = "Percent of Detached Single Homes",
title.position = c("center", "top"),
title.size = 1.2,
legend.position = c("RIGHT", "BOTTOM"),
legend.just = c("right", "bottom"),
legend.bg.color = "white",
legend.bg.alpha = 0.9,
legend.text.size = 0.6,
legend.title.size = 0.6,
inner.margins = c(0.1, 0.15, 0.1, 0.15)
)
coefPCTSINGLES
#tmap_save(coefPCTSINGLES, filename = "HW2_Plots/coefPCTSINGLES_Map.png", width = 8, height = 8, dpi = 300)
# PCTVACANT
coefPCTVACANT <- tm_shape(regress_data) +
tm_fill(
col = "coefPCTVACANTst",
breaks = c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf),
title = "Standardized Coef: PCTVACANT",
palette = "-RdBu"
) +
tm_borders(col = "gray", lwd = 0.5) +
tm_layout(
frame = FALSE,
#title = "Percent of Vacancies",
title.position = c("center", "top"),
title.size = 1.2,
legend.position = c("RIGHT", "BOTTOM"),
legend.just = c("right", "bottom"),
legend.bg.color = "white",
legend.bg.alpha = 0.9,
legend.text.size = 0.6,
legend.title.size = 0.6,
inner.margins = c(0.1, 0.15, 0.1, 0.15)
)
coefPCTVACANT
#tmap_save(coefPCTVACANT, filename = "HW2_Plots/coefPCTVACANT_Map.png", width = 8, height = 8, dpi = 300)
arranged_coef <- tmap_arrange(coefLNNBELPOV, coefPCTBACHMOR, coefPCTSINGLES, coefPCTVACANT, ncol = 4)
arranged_coef
#tmap_save(arranged_coef, filename = "HW2_Plots/arranged_coef_Map.png", width = 8, height = 8, dpi = 300)
gwr_results
gwr_adaptive_residuals <- gwr_model$SDF$gwr.e
gwr_moran_mc <- moran.mc(gwr_adaptive_residuals, queenlist, nsim = 999)
gwr_moran_mc
# GWR adaptive moran's i plot
gwr_adaptive_plot <- moran.plot(gwr_adaptive_residuals, queenlist, main = "GWR Residual Moran Plot")
# GWR adaptive moran's i plot
gwr_adaptive_plot <- moran.plot(gwr_adaptive_residuals, queenlist)
# results using fixed bandwidth
gwr_model_fixed<-gwr(formula=LNMEDHVAL ~ LNNBELPOV + PCTBACHMOR + PCTSINGLES + PCTVACANT,
data=regress_spatial,
bandwidth = bandwidth_fixed, #fixed bandwidth
gweight=gwr.Gauss,
se.fit=TRUE, #to return local standard errors
hatmatrix = TRUE)
gwr_model_fixed
# GWR adaptive moran's i
gwr_fixed_residuals <- gwr_model_fixed$SDF$gwr.e
gwr_moran_mc <- moran.mc(gwr_fixed_residuals, queenlist, nsim = 999)
gwr_moran_mc
# GWR adaptive moran's i plot
gwr_adaptive_plot <- moran.plot(gwr_fixed_residuals, queenlist)
map <- tm_shape(regress_data)+
tm_fill(col='localR2',
breaks=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7),
n=5,
palette = 'Blues',
title = expression(Local~R^2)) +  # Add custom legend title
tm_borders(col = "white", lwd = 0.5) +
tm_layout(frame=FALSE)
map
# Compute Moran's I of residuals for each model to measures remaining spatial autocorrelation.
# The closer the Moran's I statistic is to 0, the better.
moran_ols <- moran.mc(standardised_res, queenlist, 999, alternative = "two.sided")
moran_lag <- moran.mc(lag_reg$residuals, queenlist, 999, alternative = "two.sided")
moran_error <- moran.mc(error_reg$residuals, queenlist, 999, alternative = "two.sided")
moran_gwr <- moran.mc(gwr_model$SDF$gwr.e, queenlist, 999, alternative = "two.sided")
moran_ols
moran_lag
moran_error
moran_gwr
# Compare AIC values.
# The lower the AIC, the better the model fit (after penalization).
aic_ols <- AIC(ols_reg)
aic_lag <- AIC(lag_reg)
aic_error <- AIC(error_reg)
aic_gwr <- gwr_model$results$AICc   # GWR reports a corrected AIC (AICc)
aic_ols
aic_lag
aic_error
aic_gwr
ols_resid <- residuals(ols_reg)
moran.plot(ols_resid, queenlist)
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
# Scatterplot of OLS residuals vs. spatially lagged residuals
plot(
regress_data$OLS_RESIDU, regress_data$WT_RESIDU,
xlab = "OLS Residuals (eᵢ)",
ylab = "Spatially Lagged Residuals (W eᵢ)",
main = "Moran’s I Scatterplot: OLS vs Weighted Residuals",
pch = 19, col = rgb(0, 0, 0, 0.5)
)
# Add regression line
fit <- lm(WT_RESIDU ~ OLS_RESIDU, data = regress_data)
abline(fit, col = "red", lwd = 2)
# Compute statistics
r <- cor(regress_data$OLS_RESIDU, regress_data$WT_RESIDU)
R2 <- summary(fit)$r.squared
slope <- coef(fit)[2]
pval <- summary(fit)$coefficients[2, 4]
# Display Moran-style summary on plot
legend("topleft",
legend = c(
paste0("Slope (≈ Moran’s I): ", round(slope, 3)),
paste0("Correlation (r): ", round(r, 3)),
paste0("R²: ", round(R2, 3)),
paste0("p-value: ", signif(pval, 3))
),
bty = "n"
)
abline(h = 0, v = 0, col = "gray70")  # reference lines
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran.plot(regress_data$OLS_RESIDU, queenlist)
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ mp$residuals))
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$residuals))
# OLS Residual vs. WT Residual
regress_data$OLS_RESIDU <- residuals(ols_reg)
regress_data$WT_RESIDU <- lag.listw(queenlist, regress_data$OLS_RESIDU)
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$residuals))
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$x))
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# (2) Stats display as text
plot.new()
text(0, 1, adj = 0,
labels = paste0(
"Moran’s I (slope): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N = ", nrow(regress_data)
),
cex = 1.2, family = "mono")
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
# (2) Stats display as text
plot.new()
text(0, 1, adj = 0,
labels = paste0(
"Moran’s I (slope): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N = ", nrow(regress_data)
),
cex = 1.2, family = "mono")
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
# (2) Stats display as text
plot.new()
text(0, 1, adj = 0,
labels = paste0(
"Moran’s I (slope): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N = ", nrow(regress_data)
),
cex = 1.2, family = "mono")
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist.)
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
# (2) Stats display as text
plot.new()
text(0, 1, adj = 0,
labels = paste0(
"Moran’s I (slope): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N = ", nrow(regress_data)
),
cex = 1.2, family = "mono")
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1))
# (a) Plot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# (b) Text panel (not squished)
plot.new()
library(spdep)
# Create a two-row layout: plot (top), text (bottom)
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
x11()   # on Windows/Linux
# quartz()   # on macOS
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1))
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
plot.new()
library(spdep)
# Compute Moran plot data and stats once
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
# Open PNG graphics device (8×8 inches at 120 dpi → 960×960 pixels)
png("moran_plot_with_stats.png", width = 8, height = 8, units = "in", res = 120)
# Define layout: plot (top 80%), text (bottom 20%)
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1))
par(mar = c(4, 4, 3, 1))  # margins inside each panel
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# (2) Text summary panel
plot.new()
text(0, 0.8, adj = 0,
labels = paste0(
"Slope (Moran’s I): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N: ", length(regress_data$OLS_RESIDU)
),
cex = 1.2, family = "mono")
# Close and save the PNG file
dev.off()
library(spdep)
# Compute Moran plot data and stats once
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
# Open PNG graphics device (8×8 inches at 120 dpi → 960×960 pixels)
png("moran_plot_with_stats.png", width = 6, height = 8, units = "in", res = 120)
# Define layout: plot (top 80%), text (bottom 20%)
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1))
par(mar = c(4, 4, 3, 1))  # margins inside each panel
# (1) Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist,
main = "Moran’s I Scatterplot of OLS Residuals")
# (2) Text summary panel
plot.new()
text(0, 0.8, adj = 0,
labels = paste0(
"Slope (Moran’s I): ", round(coef(moran_lm)[2], 4), "\n",
"R²: ", round(moran_sum$r.squared, 4), "\n",
"p-value: ", signif(moran_sum$coefficients[2, 4], 3), "\n",
"N: ", length(regress_data$OLS_RESIDU)
),
cex = 1.2, family = "mono")
# Close and save the PNG file
dev.off()
library(spdep)
# Compute Moran plot data and stats once
library(spdep)
moran_RESIDU <- moran.plot(regress_data$OLS_RESIDU, queenlist)
moran_lm  <- lm(moran_RESIDU$wx ~ moran_RESIDU$x)
moran_sum <- summary(moran_lm)
png("moran_plot_with_stats_fixed.png", width = 6, height = 8, units = "in", res = 150)
# Give 85% of height to plot, 15% to text
layout(matrix(c(1, 2), nrow = 2), heights = c(5, 1))
par(mar = c(4, 4, 3, 1))
# Moran scatterplot
moran.plot(regress_data$OLS_RESIDU, queenlist)
# Text panel (smaller text and positioned higher)
plot.new()
png("OLS_RESIDU_Plot.png", width = 8, height = 6, units = "in", res = 150)
moran.plot(regress_data$OLS_RESIDU, queenlist)
dev.off()
names(moran_RESIDU)
summary(lm(moran_RESIDU$wx ~ moran_RESIDU$x))
